/******************************************************************************
 * $Source: /export/CVS/java/de/bb/tools/dbgen/src/main/java/de/bb/tools/dbgen/DbGen.java,v $
 * $Revision: 1.1 $
 * $Date: 2011/01/01 13:11:42 $
 * $Author: bebbo $
 * $Locker:  $
 * $State: Exp $
 *
 * Copyright (c) by Stefan Bebbo Franke 1999-2000.
 * All rights reserved
 *
 * string like class for direct byte manipulation
 *
 ******************************************************************************
 NON COMMERCIAL PUBLIC LICENSE
 ******************************************************************************

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Every product and solution using this software, must be free
 of any charge. If the software is used by a client part, the
 server part must also be free and vice versa.

 2. Each redistribution must retain the copyright notice, and
 this list of conditions and the following disclaimer.

 3. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.

 4. All advertising materials mentioning features or use of this
 software must display the following acknowledgment:
 "This product includes software developed by BebboSoft,
 written by Stefan Bebbo Franke. (http://www.bebbosoft.de)"

 5. Redistributions of any form whatsoever must retain the following
 acknowledgment:
 "This product includes software developed by BebboSoft,
 written by Stefan Bebbo Franke. (http://www.bebbosoft.de)"

 ******************************************************************************
 DISCLAIMER OF WARRANTY

 Software is provided "AS IS," without a warranty of any kind.
 You may use it on your own risk.

 ******************************************************************************
 LIMITATION OF LIABILITY

 I SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY YOU OR ANY THIRD PARTY
 AS A RESULT OF USING OR DISTRIBUTING SOFTWARE. IN NO EVENT WILL I BE LIABLE
 FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
 CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
 OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE
 SOFTWARE, EVEN IF I HAVE ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

 *****************************************************************************
 COPYRIGHT

 (c) 2002 by BebboSoft, Stefan "Bebbo" Franke, all rights reserved

 *****************************************************************************/

package de.bb.tools.dbgen;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Map.Entry;

import de.bb.util.ByteRef;
import de.bb.util.MultiMap;

/**
 * Create a complete set of EJB and RMI classes from SQL CREATE statements. Conventions:
 * <ul>
 * <li>all tables have an unique id, named "id"</li>li>all references to other tables are named "tablename_id" </li>
 * </ul>
 */
public class DbGen {
    private final static boolean DEBUG = false;

    final static String HEADER_NOMODIFY =
            "/*\r\n * This file is generated by MEJB.\r\n * DO NOT MODIFY THIS FILE!\r\n*/\r\n\r\n";

    final static String HEADER_CREATED =
            "/*\r\n * This file is initially generated by MEJB.\r\n * PLACE YOUR MODIFICATIONS HERE!\r\n*/\r\n\r\n";

    private static HashMap<ByteRef, String> javaTypes = new HashMap<ByteRef, String>();

    private static String gPath = ".";

    private static String globalPackage = "dummy";

    private static String ejbPackages = null;

    private static String gFile = null;

    private static String gSQL = null;

    private static boolean useXml = false;

    static boolean init = false;

    private static boolean verbose;

    static String baseInterface = "de.bb.mejb.Simple";

    /** the used InputStream. */
    InputStream is;

    /** read ahead buffer. */
    ByteRef br = new ByteRef();

    /** contains the current line. */
    ByteRef line = null;

    /** contains a table def. */
    ByteRef table = null;

    /** the next word. */
    ByteRef word;

    /** all tables. */
    static HashMap<String, Table> tables = new HashMap<String, Table>();

    /** contains all foreign references. */
    static MultiMap references = new MultiMap();

    /** used to quote table and coloumn names */
    static String quote = "";

    public static String idType = "String";

    public static String prefix = "\0";

    public static String dataSource = "someDataSource";

    private static String lPattern = "?Local";

    private static HashMap<String, String> defines = new HashMap<String, String>();

    private static String template;

    /**
     * Convert a package name into a path by replacing the '.' with '/'.
     * 
     * @param pack
     *            a package name
     * @return the converted file name.
     */
    static String package2Path(String pack) {
        if (pack == null)
            return null;
        byte b[] = pack.getBytes();
        for (int i = 0; i < b.length; ++i) {
            if (b[i] == '.')
                b[i] = (byte) '/';
        }
        return new String(b);
    }

    /**
     * Convert a database type into a Java type
     * 
     * @param t
     *            the database type
     * @return a java type
     */
    static String getJavaType(ByteRef t) {
        String r = (String) javaTypes.get(t);
        if (r != null)
            return r;
        return "java.lang.Object";
    }

    /**
     * Create an MEJB object.
     * 
     * @param _is
     *            the used InputStream
     */
    DbGen(InputStream _is) {
        is = _is;
    }

    /**
     * Fill the line buffer with the next line.
     * 
     * @throws Exception
     */
    void nextLine() throws Exception {
        if (br != null) {
            line = br.nextLine();
            while (line == null) {
                br = br.update(is);
                if (br == null)
                    break;
                line = br.nextLine();
            }
        }
    }

    /**
     * Get the next word from the InputStream.
     * 
     * @throws Exception
     */
    ByteRef nextWord() throws Exception {
        word = null;
        for (;;) {
            if (line == null)
                return null;
            word = line.nextWord();
            if (word != null) {
                return word;
            }
            nextLine();
        }
    }

    /**
     * Get the next word from the InputStream and use the supplied char as delimiter.
     * 
     * @param ch
     *            the delimiter character
     * @throws Exception
     */
    ByteRef nextWord(int ch) throws Exception {
        word = null;
        for (;;) {
            if (line == null)
                return null;
            word = line.nextWord(ch);
            if (word != null) {
                return word;
            }
            nextLine();
        }
    }

    /**
     * Get the table definition from the InputStream.
     * 
     * @throws Exception
     */
    void nextTable() throws Exception {
        table = null;
        if (line != null) {
            br = line.append(" ").append(br);
            line = null;
        }
        int idx;
        while ((idx = br.indexOf(';')) < 0) {
            br = br.update(is);
            if (br == null)
                return;
        }
        table = br.substring(0, idx).trim();
        table = table.trim('(').trim(')').trim();
        br = br.substring(idx + 1);
    }

    /**
     * Get the table definition from current line.
     * 
     * @throws Exception
     */
    void nextRow() throws Exception {
        line = null;
        if (table == null)
            return;
        int idx = table.indexOf(',');
        int k1 = table.indexOf('(');
        int k2 = table.indexOf(')');
        if (k1 > 0 && k1 < idx && (k2 > idx || k2 < 0)) {
            if (k2 < 0)
                idx = table.length();
            else
                idx = table.indexOf(',', k2);
        }
        if (idx < 0) {
            line = table;
            table = null;
            return;
        }
        line = table.substring(0, idx).trim();
        table = table.substring(idx + 1).trim();
    }

    /**
     * Parse the given InputStream and create an internal modell of the tables, fields and references.
     * 
     * @throws Exception
     *             on error
     */
    void parseSQL() throws Exception {
        for (nextLine(); line != null; nextLine()) {
            line = line.trim();
            // System.out.println("" + line);

            nextWord();

            boolean isAlter = false;

            // start of a table with CREATE
            if (word == null)
                continue;
            if (!word.equalsIgnoreCase("CREATE")) {
                if (!word.equalsIgnoreCase("ALTER"))
                    continue;
                isAlter = true;
            }

            nextWord();
            // TABLE key word
            if (word == null)
                continue;

            // check for sorting indexes
            boolean isUnique = false;
            if (word.equalsIgnoreCase("UNIQUE")) {
                nextWord();
                isUnique = true;
            }
            if (word.equalsIgnoreCase("INDEX")) {
                ByteRef indexName = nextWord();
                nextWord(); // ON
                ByteRef tableName = nextWord();

                // skip "using foo" till (
                nextWord('(');

                ByteRef fields = nextWord(')');
                Table table = tables.get(tableName.toString().toLowerCase());
                table.addIndex(indexName, fields, isUnique);

                continue;
            }

            if (!word.equalsIgnoreCase("TABLE"))
                continue;

            nextWord('(');
            ByteRef tableName = word.trim();

            // read the table - ends with a ';'
            nextTable();
            if (table == null)
                break;

            tableName = tableName.trim('"');
            if (verbose)
                System.out.println("parsing table: " + tableName);
            // System.out.println("" + table);

            Table current = new Table(tableName);
            if (isAlter)
                current = (Table) tables.get(current.classname.toLowerCase());

            for (nextRow(); line != null; nextRow()) {
                // System.out.println("row: " + line);
                ByteRef rowName = line.nextWord();
                if (rowName == null)
                    continue;

                if (isAlter) {
                    if (!rowName.equalsIgnoreCase("ADD"))
                        continue;
                    rowName = line.nextWord();
                    if (rowName == null)
                        continue;
                }

                if (rowName.equalsIgnoreCase("CONSTRAINT") || rowName.equalsIgnoreCase("FOREIGN")
                        || rowName.equalsIgnoreCase("INDEX") || rowName.equalsIgnoreCase("PRIMARY")
                        || rowName.equalsIgnoreCase("KEY") || rowName.equalsIgnoreCase("UNIQUE")) {
                    if (rowName.equalsIgnoreCase("CONSTRAINT")) {
                        line.nextWord(); // skip name of constraint
                        ByteRef ctype = line.nextWord();
                        int bra = ctype.indexOf('(');
                        if (bra > 0) {
                            line = ctype.substring(bra).append(line);
                            ctype = ctype.substring(0, bra);
                        }

                        if (ctype.equalsIgnoreCase("FOREIGN")) {
                            line.nextWord('('); // key (

                            ByteRef here = line.nextWord(')');
                            line = line.trim();
                            line.nextWord(); // references
                            ByteRef toTable = line.nextWord('(').trim();
                            ByteRef toField = line.nextWord(')');

                            Row row = current.rows.get(here.toLowerCase().toString());
                            Table other = tables.get(toTable);
                            // references
                            if (verbose)
                                System.out.println(here + " --> " + toTable + "." + toField);
                            continue;
                        }
                        if (ctype.equalsIgnoreCase("UNIQUE")) {
                            line = line.trim('(').trim(')').trim();
                            current.markAsUnique(line);
                            continue;
                        }
                    }
                    continue;
                }
                if (isAlter)
                    continue;

                rowName = rowName.trim('"');

                ByteRef sz1 = null;
                ByteRef sz2 = null;
                ByteRef rowType = line.nextWord();
                if (rowType == null) {
                    // System.out.println("XXX " + rowName);
                    continue;
                }
                // if '(' or even more is attached to the word, remove it and push it back to line
                if (rowType.indexOf('(') > 0) {
                    ByteRef r = rowType;
                    rowType = r.nextWord('(');
                    line = new ByteRef("(").append(r).append(" ").append(line);
                }
                // if a size is given, extract it
                if (line.charAt(0) == '(') {
                    ByteRef sz = line.nextWord(')').trim('(').trim();
                    sz1 = sz.nextWord(',');
                    sz2 = sz.nextWord();
                }
                if (verbose)
                    System.out.println("found row: " + rowName + ", " + rowType + "(" + sz1 + "," + sz2 + ")");
                current.addRow(rowName, rowType, sz1, sz2);
            }
            tables.put(current.classname.toLowerCase(), current);
        }
    }

    /**
     * Dumps the read data to stdout.
     */
    void list() {
        for (Table t : tables.values()) {
            System.out.println("table: " + t.tableName);
            for (Iterator<Row> f = t.rows.values().iterator(); f.hasNext();) {
                Row r = f.next();
                System.out.println(r);
            }
        }
    }

    /**
     * Creates all files.
     * 
     * @param path
     * @param globalPackage
     * @throws Exception
     */
    void create(String path, String globalPackage, String ejbPackage) throws Exception {
        if (verbose) {
            System.out.println("creating package " + globalPackage + " in directory " + path);
            System.out.println("using database: " + gSQL);
        }

        CodeGen cg = new JavaCodeGen();

        if (template != null) {
            cg = new TemplateGen(template);
        } else if ("ejb".equals(gSQL)) {
            cg = new EjbGen();
        } else if ("mysql".equals(gSQL)) {
            cg = new MySQLCodeGen();
        } else if ("db2".equals(gSQL)) {
            cg = new Db2CodeGen();
        } else if ("mssql".equals(gSQL)) {
            quote = "\\\"";
        } else {
            System.err.println("warning: invalid sql type specified: " + gSQL);
            // System.err.println("         using mssql instead");
            // t.createDbiMSSQL(path, pack);
        }

        defines.put("globalPackage", globalPackage);
        defines.put("ejbPackage", ejbPackage);

        cg.processTables(tables, path, defines, verbose);
        // System.out.println(references);
    }

    static {
        javaTypes.put(new ByteRef("BOOL"), "boolean");
        javaTypes.put(new ByteRef("INT"), "int");
        javaTypes.put(new ByteRef("INTEGER"), "int");
        javaTypes.put(new ByteRef("CHAR"), "java.lang.String");
        javaTypes.put(new ByteRef("VARCHAR"), "java.lang.String");
        javaTypes.put(new ByteRef("VARCHAR2"), "java.lang.String");
        javaTypes.put(new ByteRef("TEXT"), "java.lang.String");
        javaTypes.put(new ByteRef("DATE"), "java.sql.Date");
        javaTypes.put(new ByteRef("DATETIME"), "java.sql.Timestamp");
        javaTypes.put(new ByteRef("TINYINT"), "byte");
        javaTypes.put(new ByteRef("SMALLINT"), "short");
        javaTypes.put(new ByteRef("BIT"), "byte");
        javaTypes.put(new ByteRef("NUMBER"), "long");
        javaTypes.put(new ByteRef("NUMERIC"), "double");
        javaTypes.put(new ByteRef("DECIMAL"), "java.math.BigDecimal");
    }

    /**
     * create an PrintWriter for the class using the extension.
     * 
     * @param path
     *            the used path
     * @param pack
     *            the used package
     * @param filename
     * @return a PrintWriter
     * @throws Exception
     *             on error
     */
    static PrintWriter createPw(String path, String pack, String filename) throws Exception {
        String p2 = package2Path(pack);
        File d = new File(path, p2);
        d.mkdirs();
        File f = new File(d, filename);
        return new PrintWriter(new FileOutputStream(f));
    }

    private static void doOptions(String args[]) throws Exception {
        for (int i = 0; i < args.length; ++i) {
            String arg = args[i];
            if (arg.charAt(0) == '-') {
                char c = 0;
                if (arg.length() > 1)
                    c = arg.charAt(1);
                switch (c) {
                    case 'd':
                        if (++i == args.length)
                            break;
                        gPath = args[i];
                        continue;
                    case 'p':
                        if (++i == args.length)
                            break;
                        globalPackage = args[i];
                        continue;
                    case 'e':
                        if (++i == args.length)
                            break;
                        ejbPackages = args[i];
                        continue;
                    case 'x':
                        useXml = true;
                        continue;
                    case 'v':
                        verbose = true;
                        continue;
                    case 'i':
                        init = true;
                        continue;
                    case 's':
                        if (++i == args.length)
                            break;
                        gSQL = args[i];
                        continue;
                    case 't':
                        if (++i == args.length)
                            break;
                        ByteRef tm = new ByteRef(args[i]);
                        ByteRef tsql = tm.nextWord('=');
                        javaTypes.put(tsql.toUpperCase(), tm.toString());
                        break;
                    case 'b':
                        if (++i == args.length)
                            break;
                        baseInterface = args[i];
                        break;
                    case 'I':
                        if (++i == args.length)
                            break;
                        idType = args[i];
                        break;
                    case 'P':
                        if (++i == args.length)
                            break;
                        prefix = args[i];
                        break;
                    case 'S':
                        if (++i == args.length)
                            break;
                        dataSource = args[i];
                        break;
                    case 'L':
                        if (++i == args.length)
                            break;
                        lPattern = args[i];
                        break;
                    case 'T':
                        if (++i == args.length)
                            break;
                        template = args[i];
                        break;
                    case 'D':
                        int eq = args[i].indexOf('=');
                        if (eq < 0)
                            break;
                        String name = args[i].substring(2, eq);
                        String value = args[i].substring(eq + 1);
                        defines.put(name, value);
                        break;

                    default:
                        throw new Exception("invalid switch: " + arg);
                }
                if (i == args.length)
                    throw new Exception("missing value for switch: " + arg);
                continue;
            }

            if (gFile != null)
                throw new Exception("too many arguments: " + arg);

            gFile = arg;
        }
        // final checks
        if (gFile == null)
            throw new Exception("usage: DbGen" + " [-s <sqltype>=mssql]" + " [-d <dest dir>]" + " [-p <package>]"
                    + " [-e <ejb-package>]" + " [-t <typemapping>]" + " [-I <typeofId>=String]" + " [-P <tablePrefix>]"
                    + " [-v]" + " [-S <datasource>]" + " [-D<name>=<value>]" + " [-T <template>]" + " [-x]" + " [-i]"
                    + " [-L <localPattern>=?Local" + " <filename>");
    }

    static void log(String s) {
        if (DbGen.DEBUG || verbose)
            System.out.println("INFO  " + s);
    }

    static void error(String s) {
        System.out.println("ERROR " + s);
    }

    /**
     * @param args
     */
    public static void main(String args[]) {
        try {
            doOptions(args);
            if (verbose) {
                System.out.println("Type mapping:");
                for (Entry<ByteRef, String> e : javaTypes.entrySet()) {
                    System.out.println(e.getKey() + " -> " + e.getValue());
                }
            }

            if (ejbPackages == null)
                ejbPackages = globalPackage;

            FileInputStream fis = new FileInputStream(gFile);
            DbGen m = new DbGen(fis);
            if (!useXml)
                m.parseSQL();

            m.create(gPath, globalPackage, ejbPackages);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String nice(String s) {
        if (s == null)
            return s;
        StringBuffer sb = new StringBuffer();
        for (StringTokenizer st = new StringTokenizer(s, "_"); st.hasMoreElements();) {
            String p = st.nextToken();
            sb.append(p.substring(0, 1).toUpperCase());
            sb.append(p.substring(1).toLowerCase());
        }
        return sb.toString();
    }

    public static String convert(String refName) {
        if (lPattern == null)
            return refName;

        int idx = lPattern.indexOf('?');

        if (idx < 0)
            return refName + lPattern;

        return lPattern.substring(0, idx) + refName + lPattern.substring(idx + 1);
    }

}
/******************************************************************************
 * $Log: DbGen.java,v $
 * Revision 1.1  2011/01/01 13:11:42  bebbo
 * @N added to new CVS repo
 * Revision 1.32 2006/02/02 08:03:23 bebbo
 * 
 * @R modified the generated Finder class
 * 
 *    Revision 1.31 2005/02/25 10:11:11 bebbo
 * @R Home classes are now public
 * 
 *    Revision 1.30 2005/02/13 14:32:02 bebbo
 * @D set DEBUG to false
 * 
 *    Revision 1.29 2004/11/22 14:49:24 bebbo
 * @N added support to create different packages for ejb and interfaces
 * 
 *    Revision 1.28 2004/11/18 15:36:59 bebbo
 * @R changed the way how a HomeBean tracks the client
 * @B working support for many databases
 * @N transaction over many databases work
 * 
 *    Revision 1.27 2004/05/17 15:53:01 willuhn
 * @N encodeXML() is now called within CMPBean.toLog()
 * 
 *    Revision 1.26 2004/05/12 15:10:33 willuhn
 * @N Log-Ausgaben in MEJB (Namen der erzeugten Klassen und Funktionen)
 * @N Simple.toLog() ist jetzt public damit die Funktionalitaet auch von aussen genutzt werden kann (konkret: BPT:
 *    Reports via XML)
 * 
 *    Revision 1.25 2004/04/07 16:44:55 bebbo
 * @N dunno... sorry
 * 
 *    Revision 1.24 2004/03/12 14:51:26 bebbo
 * @R created code now omitts the dbi in queryCollection
 * 
 *    Revision 1.23 2004/01/26 13:39:36 bebbo
 * @R now using de.bb.brmi as RMI implementation
 * 
 *    Revision 1.22 2003/08/04 13:48:16 matz
 * @I: added DB2 support
 * @I: DECIMAL -> java.math.BigInteger
 * @I: INTEGER -> int
 * @I: de-quote tablenames
 * 
 *     Revision 1.21 2003/06/19 13:47:15 willuhn
 * @N added mapping from sql type "TEXT" to "java.lang.String"
 * 
 *    Revision 1.20 2003/04/14 14:22:11 bebbo
 * @B several fixes when LF are missing
 * 
 *    Revision 1.19 2003/02/26 14:08:12 bebbo
 * @R created code now uses queryCollection
 * 
 *    Revision 1.18 2003/02/19 13:28:50 bebbo
 * @I changed visibility of methods/fields -> more performance
 * 
 *    Revision 1.17 2003/01/27 15:00:05 bebbo
 * @R major speedup - also removed Remote functionality
 * 
 *    Revision 1.16 2003/01/07 15:08:43 bebbo
 * @N more log support
 * 
 *    Revision 1.15 2003/01/05 15:47:35 bebbo
 * @N started support for logging. Username is known to be erraneous, since it is bound to first loaded home. Must be
 *    changed in future.
 * 
 *    Revision 1.14 2003/01/03 18:19:27 bebbo
 * @R intermediate version
 * 
 *    Revision 1.13 2002/12/16 16:44:01 bebbo
 * @N generating code for MySQL with foreign key checks
 * 
 *    Revision 1.12 2002/11/27 14:03:57 bebbo
 * @R current working version
 * @I working transactions
 * @N session listener closes TAs
 * 
 *    Revision 1.11 2002/09/26 16:28:37 bebbo
 * @R quotation of table and column names is only done in MSSQL
 * 
 *    Revision 1.10 2002/09/26 11:45:44 bebbo
 * @B fixed initialization with default CT.
 * 
 *    Revision 1.9 2002/09/26 11:01:56 bebbo
 * @R complete working prototype (without transaction)
 * 
 *    Revision 1.8 2002/09/11 14:32:23 bebbo
 * @R added generation for Object base classes and base interfaces
 * 
 *    Revision 1.7 2002/09/09 09:44:36 bebbo
 * @B added Base classes and Base Interfaces for Entity-Objects
 * 
 *    Revision 1.6 2002/09/06 16:17:00 bebbo
 * @R now first working web version - with mysql
 * 
 *    Revision 1.5 2002/09/03 11:48:17 bebbo
 * @R next experimental version
 * 
 *    Revision 1.4 2002/06/03 08:41:12 bebbo
 * @R added automatic reference functions
 * 
 *    Revision 1.3 2002/05/29 10:56:02 bebbo
 * @C commented
 * 
 *****************************************************************************/
